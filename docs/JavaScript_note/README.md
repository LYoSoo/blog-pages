## 你不知道的JavaScript --读书笔记

> ​	最近看《你不知道的JavaScript》发现很有收获，这本书由浅入深感觉讲的很好，这篇读书笔记一是为了巩固自己的看到的一些东西，二是想有一些输出。



### 一、作用域

> ​	JavaScript是一门编译语言，但是相比传统编译语言，JavaScript引擎还会在语法分析和代码生产阶段有特定的步骤对性能进行优化。
>
> ```javascript
> var a = 2;
> ```
>
> 上面简单的一行代码，运行的过程如下
>
> + 看到 ` var a` 编译器会先询问在作用域中是否已经存在了该变量，如果已经存在，则会忽略该声明；如果不存在，则会声明一个新的变量，命名为 `a`。
>
> + 第二步编译器会为引擎运行时生成所需的代码，用来处理 `a = 2`这个操作。引擎首先会询问作用域，在当前作用域集合中是否存在 `a` 的变量，如果存在，使用这个变量；若不存在，继续查找该变量。
>
> + 最后如果查找到了 `a` 变量，则会把 `2` 赋值给该变量，否则会抛出异常。
>
>   **总结下来其实就是两个操作： 首先编译器在当前作用域声明一个变量（之前该变量未被声明），在运行时按照特殊的规则查找该变量（具体规则后续会说），找到了就对他赋值，未找到就抛出异常。**



**其实作用域就是根据名称查找变量的一套规则**

> ​	实际上我们通常要同时顾及好几个作用域。
>
> ​	当一个块或者函数嵌套在另一个块或者函数时，就发生了作用域嵌套。	当在上面讲的第二阶段中查找当前作用域集合中是否存在某个变量时，如果不存在，则会在外层嵌套的作用域中继续查找，直到找到该变量，或者抵达最外层的作用域位置, 也就是全局作用域 `window`。
>
> ```javascript
> 	function foo(a){
>         console.log(a + b);
>     }
> 	var b = 2;
> 	foo(2);			//4
> ```
>
> 上面就是一个典型的作用域查找规则， 在`foo`函数内部未找到变量 `b`的时候，会继续向嵌套的上层作用域查找，也就是全局作用域，在全局作用域中找到了变量 `b`。

### 二、词法作用域

> ​	我们在上面把“作用域” 看成是一套管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找的规则。
>
> ​	作用域又分为 “词法作用域”  与 “动态作用域” 两种。
>
> ​	**词法作用域是后面学习闭包的重要知识，如果不能完全清楚词法作用域，闭包也不可能理解。**
>
> ​	简单来说，词法作用域就是定义在词法阶段的作用域，是由你写代码时将变量和块作用域写在哪里决定的。
>
> ```javascript
> 	function foo(a){
> 		var b = a * 2;
>         function bar(c){
> 			console.log(a, b, c);
> 		}
>         bar(b * 3);
> 	}
> 	foo(2);			// 2, 4, 12
> ```
>
> 作用域按从外到内的分法，分别为最外层的全局作用域， 包含一个标识符： `foo` ；
>
> `foo` 函数创建的作用域， 包含三个标识符： `a` 、 `bar` 、 `b` ；
>
> `bar` 所创建的作用域，包含一个标识符： `c` ;
>
> 当引擎执行代码时，会从最内部的作用域开始查找，无法在当前作用域找到对应的变量，则会到上一级嵌套的作用域中继续查找。**作用域会在找到第一个匹配的标识符时停止。**

### 三、函数作用域和块作用域

> ​	**函数作用域： 属于这个函数的全部变量都可以在整个函数的范围内使用以及复用（嵌套的作用域也可以）。**
>
> ```javascript
> 	function foo(a){
>         var b = 2;
>         function bar(){
>             ...
>         }
>         var c = 3;
>     }
> ```
>
> > ​	上面的代码里函数 `foo` 的作用域气泡中包含了 `b` 、 `bar` 、 `c` 三个标识符，这些标识符所代表的变量或函数都属于所处作用域的气泡。
> >
> > ​	全局的作用域气泡含有 `foo`这个标识符。
> >
> > ​	所以我们在全局中只可以访问 `foo`  无法访问 `foo` 内部的作用域气泡。

##### 隐藏内部

​		上面之前我们可以看到，我们是无法从外面的作用域访问到函数内部的作用域，在软件设计中，**我们要最小限度的暴漏内部的内容，将其他内容“隐藏”起来，比如模块或者内部API设计**。

​		我们可以讲代码中的片段，用一个函数声明对他进行包装，实际就是把他隐藏了起来。

```javascript
	function doSomething(a){
        b = a + doSomethingElse(a * 2);
        console.log(b * 3);
    }
	function doSomethingElse(a){
        return a - 1;
    }
	var b;
	doSomething(2);			//15
```

> ​	上面的代码片段， 变量 `b` 和函数 `doSomethingElse` 都应该是函数  `doSomething` 的内部“私有”内容，但现在暴露在了外面， 也就是可以访问 `doSomething`的作用域同时可以访问变量 `b` 和函数 `doSomethingElse`,  这样不仅没必要，而且还是“危险的”， 造成不必要的麻烦， 合理的设计是要帮他们隐藏在 `doSomething`的内部。
>
> ```javascript
> 	function doSomething(a){
>         function doSomethingElse(a){
> 			return a - 1;
>         }
>         var b; 
>         b = a + doSomethingElse(a * 2);
>         console.log(b * 3);
>     }
> 	doSomething(2);			//15
> ```
>
> 